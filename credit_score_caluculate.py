# -*- coding: utf-8 -*-
"""credit_score_caluculate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nq5GQgyZbaqn_1wat3mTxtRcKbXmfjq3
"""

import json
import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

json_path = "/content/user-wallet-transactions.json"

with open(json_path, "r") as f:
    data = json.load(f)

df = pd.DataFrame(data)
df

df["wallet"] = df["userWallet"]
df["action"] = df["action"]

usd_values = []
for i, row in df.iterrows():
    if row["actionData"]["amount"] and row["actionData"]["assetPriceUSD"]:
        amt = float(row["actionData"]["amount"])
        price = float(row["actionData"]["assetPriceUSD"])
        usd = amt * price
    else:
        usd = 0.0
    usd_values.append(usd)

df["usd_value"] = usd_values

df["usd_value"]

df["date"] = pd.to_datetime(df["timestamp"], unit="s").dt.date
df['date']

grouped = df.groupby("userWallet")

wallet_records = []

for wallet, group in grouped:
    rec = {}
    rec["wallet"] = wallet
    rec["tx_count"] = len(group)
    rec["num_deposit"] = (group["action"] == "deposit").sum()
    rec["num_borrow"] = (group["action"] == "borrow").sum()
    rec["num_repay"] = (group["action"] == "repay").sum()
    rec["num_redeem"] = (group["action"] == "redeemunderlying").sum()
    rec["num_liquidationcall"] = (group["action"] == "liquidationcall").sum()
    rec["total_deposit_usd"] = group.loc[group["action"] == "deposit", "usd_value"].sum()
    rec["total_borrow_usd"] = group.loc[group["action"] == "borrow", "usd_value"].sum()
    rec["total_repay_usd"] = group.loc[group["action"] == "repay", "usd_value"].sum()
    rec["total_redeem_usd"] = group.loc[group["action"] == "redeemunderlying", "usd_value"].sum()
    rec["total_liquidation_usd"] = group.loc[group["action"] == "liquidationcall", "usd_value"].sum()
    rec["avg_txn_value_usd"] = group["usd_value"].mean() if len(group) > 0 else 0.0
    rec["active_days"] = group["date"].nunique()

    wallet_records.append(rec)

wallet_df = pd.DataFrame(wallet_records)

len(wallet_df)

wallet_df.drop(columns=['wallet']).corr()["num_deposit"].sort_values(ascending=False)

sns.lineplot(x="num_borrow",y='num_deposit',data=wallet_df)
plt.show()

sns.lineplot(x="active_days",y="tx_count",data=wallet_df)

#I have defined my own criteria for getting the credit value from the existing historical data

scores = []

for i, row in wallet_df.iterrows():
    score = 500


    if row["num_liquidationcall"] == 0:
        score += 200

    if row["total_borrow_usd"] > 0:
        repay_ratio = row["total_repay_usd"] / row["total_borrow_usd"]
    else:
        repay_ratio = 1.0

    if repay_ratio >= 0.9:
        score += 200

    if row["active_days"] > 30:
        score += 100

    if row["total_deposit_usd"] > 10000:
        score += 100

    if row["num_liquidationcall"] > 0:
        score -= 200

    if repay_ratio < 0.5:
        score -= 100


    score = max(0, min(1000, score))
    scores.append(score)

wallet_df["actual_credit_score"] = scores

wallet_df

X = wallet_df.drop(columns=["wallet", "actual_credit_score"])
y = wallet_df["actual_credit_score"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

X_test_scaled

model = tf.keras.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train_scaled.shape[1],)),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(1, activation='linear')
])

model.summary()

model.compile(
    optimizer="adam",
    loss='mse',
    metrics=['mae']
)

history = model.fit(
    X_train_scaled, y_train,
    epochs=20,
    batch_size=32,
    validation_split=0.2,
    verbose=1
)

losses=pd.DataFrame(model.history.history)

losses

plt.plot(losses['loss'],label='loss')
plt.plot(losses['val_loss'],label='validation_loss')
plt.plot(losses['mae'],label='mae')
plt.plot(losses['val_mae'],label='validation_mae')
plt.legend()
plt.show()

X_all_scaled = scaler.transform(X)
predicted_scores = model.predict(X_all_scaled)

predicted_scores

wallet_df["predicted_credit_score"] = predicted_scores

sns.lineplot(wallet_df.iloc[:100]["predicted_credit_score"],label='predicted_credit_score')
sns.lineplot(wallet_df.iloc[:100]["actual_credit_score"],label='actual_credit_score')

wallet_df

wallet_df.drop(columns='wallet').corr()['actual_credit_score'].sort_values(ascending=False)

